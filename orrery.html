<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Orreria</title>
    <link rel="stylesheet" href="css/orrary.css">
	</head>
	<body>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-csv/1.0.40/jquery.csv.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsonld/0.3.15/jsonld.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/90/three.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/stats.js/7/Stats.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/25.0.0/tween.umd.js"></script>
    <script src="TrackballControls.js"></script>
    <script src="OrbitalPropagator.js"></script>

        <script id="OrbitOntology" type="application/ld+json">
          {
            "@context": {
              "CelestialEntity": "http://www.w3.org/2002/07/owl#NamedIndividual",
              "Name": "http://www.w3.org/2001/XMLSchema#Name",
              "name": "http://www.semanticweb.org/rrovetto/ontologies/2014/space-situational-awareness-ontology#has_name",
              "double": "http://www.w3.org/2001/XMLSchema#double",
              "decimal": "http://www.w3.org/2001/XMLSchema#decimal",
              "graph": "@graph",
              "type": "@type",
              "value": "@value"
            },
            "graph": [
              {
                "@id": "http://www.semanticweb.org/daoneil/ontologies/2016/7/untitled-ontology-34#Mercury_Orbit",
                "type": ["CelestialEntity", "HelioCentricOrbit"],
                "name": {
                  "type": "Name",
                  "value": "Mercury_Orbit"
                },
                "eccentricity": {
                  "type": "decimal",
                  "value": "0.20563"
                },
                "inclination": {
                  "type": "decimal",
                  "value": "3.38"
                },
                "raan": {
                  "type": "decimal",
                  "value": "48.331"
                },
                "semiMajorAxis": {
                  "type": "decimal",
                  "value": "0.387098"
                },
                "sidereal": {
                  "type": "decimal",
                  "value": "88.0"
                },
                "argPerigee": {
                  "type": "decimal",
                  "value": "281.01"
                },
                "meanAnomoly": {
                  "type": "decimal",
                  "value": "29.124"
                }
              },
              {
                "@id": "http://www.semanticweb.org/daoneil/ontologies/2016/7/untitled-ontology-34#Venus_Orbit",
                "type": ["CelestialEntity", "HelioCentricOrbit"],
                "name": {
                  "type": "Name",
                  "value": "Venus_Orbit"
                },
                "eccentricity": {
                  "type": "decimal",
                  "value": "0.006772"
                },
                "inclination": {
                  "type": "decimal",
                  "value": "3.86"
                },
                "raan": {
                  "type": "decimal",
                  "value": "76.68"
                },
                "semiMajorAxis": {
                  "type": "decimal",
                  "value": "0.723332"
                },
                "sidereal": {
                  "type": "decimal",
                  "value": "224.701"
                },
                "argPerigee": {
                  "type": "decimal",
                  "value": "272.76"
                },
                "meanAnomoly": {
                  "type": "decimal",
                  "value": "54.884"
                }
              },
              {
                "@id": "http://www.semanticweb.org/daoneil/ontologies/2016/7/untitled-ontology-34#Earth_Orbit",
                "type": ["CelestialEntity", "HelioCentricOrbit"],
                "name": {
                  "type": "Name",
                  "value": "Earth_Orbit"
                },
                "eccentricity": {
                  "type": "decimal",
                  "value": "0.016708"
                },
                "inclination": {
                  "type": "decimal",
                  "value": "7.155"
                },
                "raan": {
                  "type": "decimal",
                  "value": "23.439281"
                },
                "semiMajorAxis": {
                  "type": "decimal",
                  "value": "1.0"
                },
                "sidereal": {
                  "type": "decimal",
                  "value": "365.25638"
                },
                "argPerigee": {
                  "type": "decimal",
                  "value": "-11.26064"
                },
                "meanAnomoly": {
                  "type": "decimal",
                  "value": "114.20783"
                }
              },
              {
                "@id": "http://www.semanticweb.org/daoneil/ontologies/2016/7/untitled-ontology-34#Mars_Orbit",
                "type": ["CelestialEntity", "HelioCentricOrbit"],
                "name": {
                  "type": "Name",
                  "value": "Mars_Orbit"
                },
                "eccentricity": {
                  "type": "decimal",
                  "value": "0.0934"
                },
                "inclination": {
                  "type": "decimal",
                  "value": "5.65"
                },
                "raan": {
                  "type": "decimal",
                  "value": "317.68143"
                },
                "semiMajorAxis": {
                  "type": "decimal",
                  "value": "1.523679"
                },
                "sidereal": {
                  "type": "decimal",
                  "value": "686.971"
                },
                "argPerigee": {
                  "type": "decimal",
                  "value": "49.558"
                },
                "meanAnomoly": {
                  "type": "decimal",
                  "value": "286.502"
                }
              },
              {
                "@id": "http://www.semanticweb.org/daoneil/ontologies/2016/7/untitled-ontology-34#Jupiter_Orbit",
                "type": ["CelestialEntity", "HelioCentricOrbit"],
                "name": {
                  "type": "Name",
                  "value": "Jupiter_Orbit"
                },
                "eccentricity": {
                  "type": "decimal",
                  "value": "0.0489"
                },
                "inclination": {
                  "type": "decimal",
                  "value": "6.09"
                },
                "raan": {
                  "type": "decimal",
                  "value": "268.057"
                },
                "semiMajorAxis": {
                  "type": "decimal",
                  "value": "5.2044"
                },
                "sidereal": {
                  "type": "decimal",
                  "value": "4332.59"
                },
                "argPerigee": {
                  "type": "decimal",
                  "value": "100.464"
                },
                "meanAnomoly": {
                  "type": "decimal",
                  "value": "273.867"
                }
              },
              {
                "@id": "http://www.semanticweb.org/daoneil/ontologies/2016/7/untitled-ontology-34#Saturn_Orbit",
                "type": ["CelestialEntity", "HelioCentricOrbit"],
                "name": {
                  "type": "Name",
                  "value": "Saturn_Orbit"
                },
                "eccentricity": {
                  "type": "decimal",
                  "value": "0.0565"
                },
                "inclination": {
                  "type": "decimal",
                  "value": "5.51"
                },
                "raan": {
                  "type": "decimal",
                  "value": "40.589"
                },
                "semiMajorAxis": {
                  "type": "decimal",
                  "value": "9.5826"
                },
                "sidereal": {
                  "type": "decimal",
                  "value": "10759.22"
                },
                "argPerigee": {
                  "type": "decimal",
                  "value": "113.665"
                },
                "meanAnomoly": {
                  "type": "decimal",
                  "value": "339.392"
                }
              },
              {
                "@id": "http://www.semanticweb.org/daoneil/ontologies/2016/7/untitled-ontology-34#Uranus_Orbit",
                "type": ["CelestialEntity", "HelioCentricOrbit"],
                "name": {
                  "type": "Name",
                  "value": "Uranus_Orbit"
                },
                "eccentricity": {
                  "type": "decimal",
                  "value": "0.046381"
                },
                "inclination": {
                  "type": "decimal",
                  "value": "6.48"
                },
                "raan": {
                  "type": "decimal",
                  "value": "257.311"
                },
                "semiMajorAxis": {
                  "type": "decimal",
                  "value": "19.2184"
                },
                "sidereal": {
                  "type": "decimal",
                  "value": "30688.5"
                },
                "argPerigee": {
                  "type": "decimal",
                  "value": "74.006"
                },
                "meanAnomoly": {
                  "type": "decimal",
                  "value": "96.998856"
                }
              },
              {
                "@id": "http://www.semanticweb.org/daoneil/ontologies/2016/7/untitled-ontology-34#Neptune_Orbit",
                "type": ["CelestialEntity", "HelioCentricOrbit"],
                "name": {
                  "type": "Name",
                  "value": "Neptune_Orbit"
                },
                "eccentricity": {
                  "type": "decimal",
                  "value": "0.009456"
                },
                "inclination": {
                  "type": "decimal",
                  "value": "6.43"
                },
                "raan": {
                  "type": "decimal",
                  "value": "131.784"
                },
                "semiMajorAxis": {
                  "type": "decimal",
                  "value": "30.110387"
                },
                "sidereal": {
                  "type": "decimal",
                  "value": "60190.03"
                },
                "argPerigee": {
                  "type": "decimal",
                  "value": "131.721"
                },
                "meanAnomoly": {
                  "type": "decimal",
                  "value": "45.0"
                }
              }
            ]
          }
          
          
        </script>

        <div class="panel">
          <h1>Planet</h1>
          <div class="subtitle">Gas Giant</div>
          <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce eleifend tortor dolor, id dapibus ex maximus ac. Duis rhoncus hendrerit libero vitae tincidunt.</p>
      
          <!-- <div class="special-options">
              <a href="#">Compare size &#9658;</a>
              <a href="#">Explore Surface &#9658;</a>
          </div> -->
      </div>

      <div class="layers-panel">
        <h2 class="panel-title">Layers</h2>
        <div class="layer-section">
          <p class="section-title">User Interface</p>
          <div class="layer-item">
            <input type="checkbox" id="planets" checked />
            <label for="planets">Planets</label>
          </div>
          <div class="layer-item">
            <input type="checkbox" id="asteroids" />
            <label for="asteroids">Asteroids</label>
          </div>
          <div class="layer-item">
            <input type="checkbox" id="comets" />
            <label for="comets">Comets</label>
          </div>
        </div>
        <div class="layer-section">
          <div class="layer-item">
            <input type="checkbox" id="spacecrafts" />
            <label for="spacecrafts">Spacecrafts</label>
          </div>
          <div class="layer-item">
            <input type="checkbox" id="trails" />
            <label for="trails">Trails</label>
          </div>
          <div class="layer-item">
            <input type="checkbox" id="orbits" />
            <label for="orbits">Orbits</label>
          </div>
          <div class="layer-item">
            <input type="checkbox" id="labels" />
            <label for="labels">Labels</label>
          </div>
          <div class="layer-item">
            <input type="checkbox" id="icons" />
            <label for="icons">Icons</label>
          </div>
        </div>
      </div>

      <script>
        // Select all checkboxes in the document
        const checkboxes = document.querySelectorAll('.layers-panel input[type="checkbox"]');
      
        // Function to handle checkbox clicks
        function handleCheckboxClick(event) {
          const checkboxId = event.target.id;
          const isChecked = event.target.checked;
          console.log(`Checkbox with ID ${checkboxId} is now ${isChecked ? 'checked' : 'unchecked'}`);
          switch (checkboxId) {
            case 'planets':
              planetsOrbits.forEach(planetOrbit => {
                planetOrbit.visible = isChecked ? true : false;
              });
              break;
            case 'asteroids':
              AstroidsOrbits.forEach(AstroidsOrbit => {
                AstroidsOrbit.visible = isChecked ? true : false;
              });
              break;
            case 'comets':
              if (isChecked) {
                console.log('Showing comets layer');
                // Add your logic to show the comets layer
              } else {
                console.log('Hiding comets layer');
                // Add your logic to hide the comets layer
              }
              break;
            case 'spacecrafts':
              if (isChecked) {
                console.log('Showing spacecrafts layer');
                // Add your logic to show the spacecrafts layer
              } else {
                console.log('Hiding spacecrafts layer');
                // Add your logic to hide the spacecrafts layer
              }
              break;
            case 'trails':
              if (isChecked) {
                console.log('Showing trails layer');
                // Add your logic to show the trails layer
              } else {
                console.log('Hiding trails layer');
                // Add your logic to hide the trails layer
              }
              break;
            case 'orbits':
              if (isChecked) {
                console.log('Showing orbits layer');
                // Add your logic to show the orbits layer
              } else {
                console.log('Hiding orbits layer');
                // Add your logic to hide the orbits layer
              }
              break;
            case 'labels':
              if (isChecked) {
                console.log('Showing labels layer');
                // Add your logic to show the labels layer
              } else {
                console.log('Hiding labels layer');
                // Add your logic to hide the labels layer
              }
              break;
            case 'icons':
              if (isChecked) {
                console.log('Showing icons layer');
                // Add your logic to show the icons layer
              } else {
                console.log('Hiding icons layer');
                // Add your logic to hide the icons layer
              }
              break;
            default:
              console.log('Unknown layer');
          }
        }
      
        // Attach the event listener to each checkbox
        checkboxes.forEach(checkbox => {
          checkbox.addEventListener('click', handleCheckboxClick);
        });
        $('.layers-panel').show();
      </script>
      
		<script>
    var raycaster, mouse, planets = [];
    var camera;
		var controls;
		var scene;
		var cube;
		var sphere;
    var sun;
    var rings;
		var line;
    var world;
    var stats;
    var sunglow;
    var targetPlanet = null; // The planet that camera will follow
    var offsetDistance = 0.2; // Distance from the planet
    var threshold = 0.3;
    var siteUrl = window.location.href.substring(0, window.location.href.lastIndexOf('/')) + '/';
    var objNames = ["Mercury_Orbit", "Venus_Orbit", "Earth_Orbit", "Mars_Orbit", "Jupiter_Orbit", "Saturn_Orbit", "Uranus_Orbit", "Neptune_Orbit"];
    var objLen = objNames.length;
    var objSizes = [0.0000595, 0.0001479, 0.0001547, 0.0000833, 0.0017085, 0.0014195, 0.0006188, 0.0006001];
    const textureLoader = new THREE.TextureLoader();
    const starsTexture = textureLoader.load(siteUrl+'/planets/starmap_4096.jpg');
    const sunTexture = textureLoader.load(siteUrl+'/planets/8k_sun.jpg');
    const mercuryTexture = textureLoader.load(siteUrl+'/planets/2k_mercury.jpg');
    const venusTexture = textureLoader.load(siteUrl+'/planets/2k_venus.jpg');
    const earthTexture = textureLoader.load(siteUrl+'/planets/2k_earth.jpg');
    const marsTexture = textureLoader.load(siteUrl+'/planets/2k_mars.jpg');
    const jupiterTexture = textureLoader.load(siteUrl+'/planets/2k_jupiter.jpg');
    const saturnTexture = textureLoader.load(siteUrl+'/planets/2k_saturn.jpg');
    const uranusTexture = textureLoader.load(siteUrl+'/planets/2k_uranus.jpg');
    const neptuneTexture = textureLoader.load(siteUrl+'/planets/2k_neptune.jpg');

    var textures = [mercuryTexture, venusTexture, earthTexture, marsTexture, jupiterTexture, saturnTexture, uranusTexture, neptuneTexture]
		var curObj = new THREE.Object3D();
		var celestialBody;
		var heavenlyBodies = [];
    var Astroids = [];
    var planetsOrbits = [];
    var AstroidsOrbits = [];
    var spacecrafts = [];
		
		function init() {
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
			  controls = new THREE.TrackballControls(camera);
				controls.rotateSpeed = 2.0;
				controls.zoomSpeed = 7.0;
				controls.panSpeed = 1;
				controls.noZoom = false;
				controls.noPan = false;
				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;
        controls.minDistance = 0.17;
        controls.maxDistance = 100;
				controls.keys = [65, 83, 68];

        stats = new Stats();
				
			  scene = new THREE.Scene();
								
        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(window.innerWidth, window.innerHeight);
        // document.body.appendChild(stats.domElement);
        document.body.appendChild(renderer.domElement);
        window.addEventListener('resize', onResize, true);

        raycaster = new THREE.Raycaster();
        mouse = new THREE.Vector2();

		    var j = 0;

        var worldGeometry = new THREE.SphereGeometry(500,60,60);
        var worldMaterial = new THREE.MeshBasicMaterial(
          { color: 0xffffff ,
          map: starsTexture ,
          side: THREE.BackSide
          });
        world = new THREE.Mesh(worldGeometry, worldMaterial);
        scene.add(world);

      	//  Here comes the Sun!
        // Create the Sun (Core)
        var geometry = new THREE.SphereGeometry(0.05, 60, 60);
        var material = new THREE.MeshBasicMaterial({map: sunTexture ,reflectivity:3, shininess :3});
        sun = new THREE.Mesh(geometry, material);
        scene.add(sun);


        // // Create the glow effect around the sun
        var glowGeometry = new THREE.SphereGeometry(0.05, 60, 60); // Slightly larger sphere for the glow border
        var glowMaterial = new THREE.MeshBasicMaterial({
            color: 0xf5bf6e, // Orange color for vintage effect
            transparent: true,
            opacity: 0.9, // Adjust for desired strength of the glow
            blending: THREE.AdditiveBlending // Blend mode for a soft glow effect
        });
        var glowMesh = new THREE.Mesh(glowGeometry, glowMaterial);
        sun.add(glowMesh); // Add the glow mesh around the sun

        // Optional: Create a glowing edge effect with texture
        var glowTextureLoader = new THREE.TextureLoader();
        var glowTexture = glowTextureLoader.load(siteUrl+'/Shaders/glow2.png'); // Load a texture
        var glowSpriteMaterial = new THREE.SpriteMaterial({
            map: glowTexture,
            color: 0xffcd38, // Orange color for the texture
            transparent: false,
            opacity: 1, // Adjust opacity for strength
            blending: THREE.AdditiveBlending
        });

        // Create a sprite for the glowing edge effect
        sunglow = new THREE.Sprite(glowSpriteMaterial);
        sunglow.scale.set(0.5, 0.5, 1.4); // Adjust size of the glow sprite
        glowMesh.add(sunglow); // Attach the glow sprite to the glow mesh





        // // Create fog effect
        // var fogGeometry = new THREE.SphereGeometry(0.05, 60, 60); 
        // var fogMaterial = new THREE.MeshBasicMaterial({
        //   color: 0xffffff,
        //   transparent: true,
        //   opacity: 0.1, // Adjust for desired strength of the glow
        //   blending: THREE.AdditiveBlending // Blend mode for a soft glow effect
        // });
        // var fogMesh = new THREE.Mesh(fogGeometry, fogMaterial);
        // sun.add(fogMesh); // Add the fog mesh around the sun

        // // Optional: Create a fog edge effect with texture
        // var fogTextureLoader = new THREE.TextureLoader();
        // var fogTexture = fogTextureLoader.load(siteUrl+'/Shaders/fog1.png'); // Load a texture

        // var fogSpriteMaterial = new THREE.SpriteMaterial({
        //     map: fogTexture,
        //     color: 0xffcd38, 
        //     transparent: true,
        //     opacity: 1, // Adjust opacity for strength
        //     blending: THREE.AdditiveBlending
        // });

        // // Create a sprite for the glowing edge effect
        // spaceFog = new THREE.Sprite(fogSpriteMaterial);
        // spaceFog.scale.set(50, 50, 100); // Adjust size of the glow sprite
        // fogMesh.add(spaceFog); // Attach the glow sprite to the glow mesh






        // Set camera position
        camera.position.set(0, 100, 200); // Adjust as necessary
        camera.lookAt(0, 0, 0); // Look at the center

        // Enable shadow maps
        renderer.shadowMap.enabled = true;

        // Add the inner planets.
        for (i = 0; i < objLen; i++) { 
            // Create the planet geometry and material
            geometry = new THREE.SphereGeometry(objSizes[j] * 50, 60, 60);
            material = new THREE.MeshStandardMaterial({ map: textures[j] }); // Use MeshStandardMaterial instead
            planet = new THREE.Mesh(geometry, material);
            
            // Set the name of the planet
            planet.name = objNames[i];
            
            // Position the planet
            planet.position.x = 5; // Adjust this as necessary for your scene
            planet.rotation.y = 8; // Adjust rotation if needed
            planets.push(planet);
            
            // Add planet to the scene
            scene.add(planet);
            
            // Saturn Ring
            if (i === 5) {
                const ringGeometry = new THREE.RingBufferGeometry(3, 5, 64);
                var pos = ringGeometry.attributes.position;
                var v3 = new THREE.Vector3();
                for (let i = 0; i < pos.count; i++){
                    v3.fromBufferAttribute(pos, i);
                    ringGeometry.attributes.uv.setXY(i, v3.length() < 4 ? 0 : 1, 1);
                }
                
                const ringTexture = new THREE.TextureLoader().load("https://i.postimg.cc/zz7Gr430/saturn-rings-top.png");

                const ringMaterial = new THREE.MeshStandardMaterial({ // Use MeshStandardMaterial for the rings
                    map: ringTexture,
                    side: THREE.DoubleSide,
                    transparent: true
                });

                rings = new THREE.Mesh(ringGeometry, ringMaterial); 

                // Rotate rings to lie flat
                rings.rotation.x = Math.PI / 2;

                // Scale rings to match Saturn's size
                rings.scale.set(0.03, 0.03, 0.03);

                // Set position slightly above Saturn
                rings.position.set(0, 0, 0); 

                // Add rings to the scene
                scene.add(rings);
            }

            // Create and add the hemisphere light
            const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.5); // Adjust intensity
            hemisphereLight.color.setHSL(0, 0, 0.1);
            hemisphereLight.groundColor.setHSL( 0, 0, -0.01 );
            hemisphereLight.position.set( 0, 120, 0 );
            scene.add(hemisphereLight);

            // Create and add the planet light (DirectionalLight)
            const planetLight = new THREE.DirectionalLight(0xffffff, 0.1); 
            planetLight.position.set(-1, 20, 1); // Adjust position
            planetLight.castShadow = true; // Enable shadow casting
            scene.add(planetLight);

            // Increment j for the next planet
            j = j + 1;
        }

        document.addEventListener('mousedown', onDocumentMouseDown, false); 
        camera.position.x = 0;
        camera.position.y = -100;
        camera.position.z = 30;		
		}

 	 	function render() {
      requestAnimationFrame(render);
      renderer.render(scene, camera);
      }  

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      stats.update();
      updatePosition();
      followPlanet();
      world.rotation.y += 0.0001;
      world.rotation.x += 0.00025;
      var distance = camera.position.distanceTo(controls.target);
      if(distance > 1)
      {
        sunglow.scale.set(0.4 * distance/3, 0.4 * distance/3, 1.3 * distance/3);
      } else {
        sunglow.scale.set(0.5, 0.5, 1.4);
      }
      sun.rotation.y += 0.0001;
      sun.rotation.x += 0.001;

      for (i = 0; i < objLen; i++) {
        curObj = scene.getObjectByName(objNames[i]);
        if(rings && curObj.name === "Saturn_Orbit")
        {
          rings.position.copy(curObj.position);
        }
        curObj.rotation.y += 0.001
        // curObj.rotation.x += 0.01
        }

      renderer.render(scene, camera);
      }
     
    function onResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function onDocumentMouseDown(event) {
        event.preventDefault();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        var intersects = raycaster.intersectObjects(planets);

        if (intersects.length > 0) {
          var selectedPlanet = intersects[0].object;
          targetPlanet = intersects[0].object;
          console.log("Selected Planet:", targetPlanet.name);
          zoomToPlanet(selectedPlanet);
          $('.panel h1').text(selectedPlanet.name.split('_')[0]);
          $.get('https://planets-17f2.onrender.com/planets/getPlanet?name=' + selectedPlanet.name.split('_')[0], function(data) {
              $('.panel .subtitle').text(data.tagline);
              $('.panel p').text(data.description);
              $('.panel').show();
          })


        } else {
        for (var i = 0; i < planets.length; i++) {
            var planet = planets[i];
            var planetPosition = new THREE.Vector3();
            planet.getWorldPosition(planetPosition);

            var distance = raycaster.ray.distanceToPoint(planetPosition);

            if (distance < threshold) { 
                zoomToPlanet(planet);
                targetPlanet = planet;
                $('.panel h1').text(planet.name.split('_')[0]);
                $.get('https://planets-17f2.onrender.com/planets/getPlanet?name=' + planet.name.split('_')[0], function(data) {
                  $('.panel .subtitle').text(data.tagline);
                  $('.panel p').text(data.description);
                  $('.panel').show();
              })
                break;
            }
        }
      }
      }

function zoomToPlanet(planet) {
    var targetPosition = planet.position.clone(); // Clone the planet's position
    var zoomDistance = 3; // Adjust zoom distance based on the scale of your scene

    // Camera controls adjustments for smoother behavior
    controls.rotateSpeed = 2.0;  // Reduced rotate speed for smoother rotations
    controls.zoomSpeed = 7.0;    // Reduced zoom speed for smoother zooming
    controls.panSpeed = 1;     // Reduce pan speed for smoother panning
    controls.noZoom = false;
    controls.noPan = false;
    controls.staticMoving = true; // Enable dynamic movement for smoothness
    controls.dynamicDampingFactor = 100; // Increase damping for even smoother control response
    controls.minDistance = 0.17;
    controls.maxDistance = 0.17
    controls.keys = [65, 83, 68]; // Control keys

    // Smooth transition for the camera position
    new TWEEN.Tween(camera.position)
        .to({
            x: targetPosition.x * zoomDistance,
            y: targetPosition.y * zoomDistance,
            z: targetPosition.z * zoomDistance
        }, 3000) // Further increased duration for smoother transition (3000ms)
        .easing(TWEEN.Easing.Quadratic.Out) // Use a softer easing for smoother motion
        .onUpdate(() => {
            controls.target.copy(targetPosition); // Continuously update target
        })
        .start();

    // Smoothly adjust the controls' target
    new TWEEN.Tween(controls.target)
        .to({
            x: targetPosition.x,
            y: targetPosition.y,
            z: targetPosition.z
        }, 3000) // Match the camera movement duration
        .easing(TWEEN.Easing.Quadratic.Out)
        .start();
}

function followPlanet() {
    if (targetPlanet) {
        const planetPosition = new THREE.Vector3();
        targetPlanet.getWorldPosition(planetPosition); // Get the target planet's position in world space

        // Get the target planet's size (assuming uniform scaling for simplicity)
        const planetSize = targetPlanet.geometry.boundingSphere.radius; // or any axis scale if non-uniform

        // Calculate the target camera position with an offset based on the planet's size
        const cameraTargetPosition = planetPosition.clone().add(new THREE.Vector3(planetSize * offsetDistance, planetSize * offsetDistance, planetSize * offsetDistance));

        // Smoothly interpolate the camera's position towards the target
        camera.position.lerp(cameraTargetPosition, 0.02); // Reduced lerp factor for even slower, smoother transitions

        // Ensure the camera smoothly looks at the target planet
        camera.lookAt(planetPosition);

        // Smoothly adjust the controls' target
        controls.target.lerp(planetPosition, 0.015); // Use lower lerp for slower movement
    }
}





   function get_datablock() {
    // Reference https://stackoverflow.com/questions/38602543/is-there-a-way-to-access-json-ld-via-javascript-if-it-doesnt-have-an-id
	  // var jsonld = document.querySelectorAll('script[type="application/ld+json"]').innerText;
		var jsonld = document.querySelector('#OrbitOntology').innerText;
    var result = JSON.parse(jsonld);
    for(i = 0; i < result.graph.length; i++) {
      field = result.graph[i];
      if (i >= 0 && i <= objLen) { // alert(field.name.value); 

        //smA,oI,aP,oE,aN,mAe,Sidereal
        celestialBody = new Trajectory(field.name.value,
                            field.semiMajorAxis.value,
              field.inclination.value,
              field.argPerigee.value,
              field.eccentricity.value,
              field.raan.value,
              field.meanAnomoly.value,
              field.sidereal.value);
  
        heavenlyBodies.push(celestialBody);

      }		 

		}
}

function loadAstroids() {
  return new Promise((resolve, reject) => {
    $.get(siteUrl+"/data.csv", function(CSVdata) {
      data = $.csv.toObjects(CSVdata);
      data.forEach(element => {
        celestialBody = new Trajectory(
          element.full_name,
          element.a,
          element.i,
          element.w,
          element.e,
          element.om,
          element.ma,
          element.per
        );

        geometry = new THREE.SphereGeometry( 0.0009, 60, 60);
        material = new THREE.MeshBasicMaterial({ map: mercuryTexture });
        sphere = new THREE.Mesh(geometry, material);
        
        sphere.name = element.full_name;
        scene.add(sphere);

        Astroids.push(celestialBody);
        heavenlyBodies.push(celestialBody);
      });
      console.log(data);
      resolve();
    }).fail((err) => reject(err));
  });
}

async function initApp() {
  init();
  get_datablock();
  await loadAstroids();
  traceOrbits();
  animate();
  onResize();
  render();
}

initApp();
		  
		</script>
	</body>
</html>